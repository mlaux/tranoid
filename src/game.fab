// Main gameplay mode

ct U[] game_palette = U[] (
    $0f, $10, $11, // black keys lanes
    $2d, $10, $30, // white keys lanes and score
    $0f, $10, $16, // scratch lane
    $0f, $0f, $0f, 

    $2c, $27, $30, // tran color
    $0f, $0f, $0f, 
    $0f, $0f, $0f, 
    $0f, $0f, $0f, 

    $0f,
)

ct U MIN_X = $10
ct U MAX_X = $f0
ct U MIN_Y = $38
ct U MAX_Y = $b8

ct U TILE_LEFT_RUNNING = $b0
ct U TILE_RIGHT_RUNNING = $b2
ct U TILE_LEFT_STANDING = $b4
ct U TILE_RIGHT_STANDING = $b6
ct U WIDTH_IN_TILES = $40
ct U START_OFFSET = $10

ct U TRAN_ICON = $f7
ct U ENEMY_ICON = $f8
ct U ENEMY_ICON_SCRATCH = $f9
ct U ENEMY_LEGS = $fa
ct U EMPTY_TOP_BORDER = $fc
ct U EMPTY_LANE = $ff
ct U DEBUG_INDICATOR = $ce

ct U TRAN_SPRITE_OAM_OFFSET_LEFT = $4
ct U TRAN_SPRITE_OAM_OFFSET_RIGHT = $8
ct U SCORE_SPLIT_POINT = $1f // tile in BG is at y = $20
ct U SPRITE_ZERO_ID = $b8

vars /game
    Bool dead = false
    Bool won = false
    U active_nt = 0
    UF scroll_x = 0
    UF last_scroll = 0
    U next_column = START_OFFSET
    UU chart_offset = 0
    UF player_x = $78
    UF player_y = $80
    U anim_ctr = 0
    CCC/charts use_chart

data /rlz
    [] game_screen
        file(rlz, "game.nam")

// modified from hang glider example
ct fn tile_ppuaddr_table() UU[WIDTH_IN_TILES]
    UU[WIDTH_IN_TILES] ret
    for U i = 0; i < 32; i += 1
        ret[i] = $20c0 + UU(i)
        ret[i + 32] = $24c0 + UU(i)
    return ret

fn check_tile_under_player(UU addr) Bool
: +inline
    ppu_reset_addr(addr)
    {PPUDATA}()
    UU tile_below = {PPUDATA}()
    return tile_below == ENEMY_ICON || tile_below == ENEMY_ICON_SCRATCH || tile_below == ENEMY_LEGS

nmi game_nmi()
    if ready
        ppu_upload_oam_poll_pads(0)
        ppu_upload_palette()

    // get player X position as a value from 0 to ff which is a pixel offset
    // in the current nametable
    // https://github.com/pubby/nesfab/issues/35
    // workaround: OR with $100 first
    UU use_x = (UU(scroll_x.a) | $0100) + UU(player_x.a)
    use_x -= $100
    if active_nt != 0
        use_x += $100
    if use_x > $1ff
        use_x -= $200

    // leaving in as an example of how to use the logging
    // log_3(@"scroll: %04x, player: %04x, sum: %04x"ascii, UU(scroll_x.a), UU(player_x.a), use_x)

    UU nt_base = $2000
    if use_x >= $100
        nt_base = $2400

    // convert from pixel coordinates to tile address
    UU xy_addr = nt_base + (UU(player_y.a >> 3) << 5) + (use_x >> 3)
    if use_x >= $100
        xy_addr -= $20 // why?

    // check for collision with enemy
    if check_tile_under_player(xy_addr) || check_tile_under_player(xy_addr + $20)
        //dead = true

    // ppu_reset_addr(xy_addr)
    // {PPUDATA}(DEBUG_INDICATOR)
    // ppu_reset_addr(xy_addr + $20)
    // {PPUDATA}(DEBUG_INDICATOR)

    // there is probably an easier way to do this
    Bool crossed_tile_boundary = last_scroll.a >> 3 != scroll_x.a >> 3
    if crossed_tile_boundary
        load_column()

    ppu_reset_scroll(0, 0)
    {PPUCTRL}(PPUCTRL_NMI_ON | PPUCTRL_SPR_8X16 | active_nt)
    {PPUMASK}(PPUMASK_ON | PPUMASK_NO_CLIP)

    ppu_await_status(PPUSTATUS_SPR_0)
    ppu_reset_scroll(scroll_x.a, 0)

    puf.process(%1111)

fn emit_tile(U k)
: +inline
    if (use_chart{chart_offset} >> k) & 1
        {PPUDATA}(ENEMY_ICON)
        {PPUDATA}(ENEMY_LEGS)
    else
        {PPUDATA}(EMPTY_TOP_BORDER)
        {PPUDATA}(EMPTY_LANE)

fn load_column()
    if chart_offset == len(chart)
        won = true
        return

    {PPUCTRL}(PPUCTRL_VRAM_32_DOWN)

    {PPUSTATUS}()
    {PPUADDR}(tile_ppuaddr_table()[next_column].b)
    {PPUADDR}(tile_ppuaddr_table()[next_column].a)
    {PPUDATA}(EMPTY_TOP_BORDER)
    if (use_chart{chart_offset} >> 7) & 1
        {PPUDATA}(ENEMY_ICON_SCRATCH)
        {PPUDATA}(ENEMY_LEGS)
    else
        {PPUDATA}(EMPTY_LANE)
        {PPUDATA}(EMPTY_LANE)
    {PPUDATA}($00)
    emit_tile(6)
    emit_tile(5)
    emit_tile(4)
    emit_tile(3)
    emit_tile(2)
    emit_tile(1)
    emit_tile(0)
    {PPUDATA}(EMPTY_TOP_BORDER)

    next_column += 1
    if next_column == WIDTH_IN_TILES
        next_column = 0
    chart_offset += 1

mode game(Bool another_mode)
: nmi game_nmi
    {PPUCTRL}(0)
    {PPUMASK}(0)

    state(0)

    if another_mode
        use_chart = @another
    else
        use_chart = @chart

    // this does not work with a 'ct' array??
    // I think this is the same thing that was going on with the delays in
    // attract mode
    // for U k = 0; k < len(tran_palette); k += 1
    //     palette[PALETTE_SPR + k] = tran_palette[k]
    // compiles to:
    // 8A2C  A9 2C          LDA #$2C
    // 8A2E  8D 0C 03       STA $030C
    // 8A31  8D 0D 03       STA $030D
    // 8A34  A2 30          LDX #$30
    // 8A36  8E 0E 03       STX $030E
    // 8A39  20 C0 8C       JSR ppu_upload_palette@0_0

    palette = game_palette
    ppu_upload_palette()

    ppu_reset_addr($2000)
    ppu_upload_rlz(@game_screen)
    ppu_reset_addr($2400)
    ppu_upload_rlz(@game_screen)

    for U k = 0; k < 24; k += 1
        load_column()

    hide_oam(0)
    // use palette 1 because it's all blank
    set_oam(0, 0, SCORE_SPLIT_POINT, SPRITE_ZERO_ID, 1)

    {PPUCTRL}(PPUCTRL_NMI_ON)

    puf.play_track(0)

    while true
        if won
            goto mode title(true) : preserves
        if dead
            puf.stop(0)
            puf.play_sfx(SFX_DEAD)
            goto mode title(false) : preserves

        update_pads()

        U player_moving = pads[0].held & BUTTON_DPAD
        U player_flags = 0 // for horizontal flip
        UF new_x = player_x
        UF new_y = player_y

        if pads[0].held & BUTTON_RIGHT
            new_x += 1.5
        if pads[0].held & BUTTON_UP
            new_y -= 1.5
        if pads[0].held & BUTTON_LEFT
            new_x -= 1.5
            player_flags |= ATTR_H_FLIP
        if pads[0].held & BUTTON_DOWN
            new_y += 1.5

        if new_x >= MIN_X && new_x < MAX_X
            player_x = new_x
        if new_y >= MIN_Y && new_y < MAX_Y
            player_y = new_y

        U tile_left = TILE_LEFT_STANDING
        U tile_right = TILE_RIGHT_STANDING
        if anim_ctr >= 6 // && player_moving
            state(3)
            tile_left = TILE_LEFT_RUNNING
            tile_right = TILE_RIGHT_RUNNING
        else
            state(0)

        // need to swap the tile IDs not just the tile contents
        if player_flags
            U temp = tile_left
            tile_left = tile_right
            tile_right = temp

        set_oam(TRAN_SPRITE_OAM_OFFSET_LEFT, player_x.a - 4, player_y.a - 4, 
                tile_left, player_flags)
        set_oam(TRAN_SPRITE_OAM_OFFSET_RIGHT, player_x.a + 4, player_y.a - 4, 
                tile_right, player_flags)

        last_scroll = scroll_x

        // 1/16 note = 1 row in the tracker = 1 byte in the chart = 1 column in the nametable
        // tracker "speed" setting is set to 5, so 5 frames = 1/16 note
        // this means I want to scroll 8 pixels in 5 frames, 8/5 = 1.6 scroll per frame

        // there is no exact representation of 1.6 in 8.8 bit fixed point, so this
        // gets rounded to 1.6015625, but it's close enough that I can't notice
        // the song desyncing

        if (scroll_x += 1.6) // evaluates to true if it overflowed
            active_nt ^= PPUCTRL_NT_2400

        anim_ctr += 1
        if anim_ctr >= 12
            anim_ctr = 0

        //{PPUMASK}(PPUMASK_ON | PPUMASK_NO_CLIP | PPUMASK_EMPHASIZE_R | PPUMASK_EMPHASIZE_G | PPUMASK_EMPHASIZE_B)
        frame += 1
        nmi