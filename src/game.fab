// Main gameplay mode

// ct U[3] tran_palette = U[3] ($2c, $27, $30)

ct U[] game_palette = U[] (
    $0f, $10, $11, // black keys lanes
    $2d, $10, $30, // white keys lanes
    $0f, $10, $16, // scratch lane
    $0f, $0f, $0f, 

    $2c, $27, $30, // tran color
    $0f, $0f, $0f, 
    $0f, $0f, $0f, 
    $0f, $0f, $0f, 

    $0f,
)

ct U MIN_X = $10
ct U MAX_X = $f0
ct U MIN_Y = $38
ct U MAX_Y = $b8

ct U TILE_LEFT_RUNNING = $b0
ct U TILE_RIGHT_RUNNING = $b2
ct U TILE_LEFT_STANDING = $b4
ct U TILE_RIGHT_STANDING = $b6
ct U WIDTH_IN_TILES = $40
ct U START_OFFSET = $1f

ct U TRAN_ICON = $f7
ct U ENEMY_ICON = $f8
ct U ENEMY_ICON_SCRATCH = $f9
ct U ENEMY_LEGS = $fa
ct U EMPTY_TOP_BORDER = $fc
ct U EMPTY_LANE = $ff
ct U DEBUG_INDICATOR = $ce

vars /game
    Bool dead = false
    Bool won = false
    U active_nt = 0
    UF scroll_x = 0
    U next_column = START_OFFSET
    UU chart_offset = 0
    UF player_x = $78
    UF player_y = $70
    U anim_ctr = 0
    CCC/charts use_chart = @chart // @another

    // U[3] tran_palette = U[3] ($2c, $27, $30)

data /rlz
    [] game_screen
        file(rlz, "game.nam")

// modified from hang glider example
ct fn tile_ppuaddr_table() UU[WIDTH_IN_TILES]
    UU[WIDTH_IN_TILES] ret
    for U i = 0; i < 32; i += 1
        ret[i] = $20c0 + UU(i)
        ret[i + 32] = $24c0 + UU(i)
    return ret

nmi game_nmi()
    if ready
        ppu_upload_oam_poll_pads(0)
        ppu_upload_palette()

    // https://github.com/pubby/nesfab/issues/35
    // workaround: OR with $100 first
    UU use_x = (UU(scroll_x.a) | $0100) + UU(player_x.a)
    use_x -= $100
    if active_nt != 0
        use_x += $100
    if use_x > $1ff
        use_x -= $200

    // log_3(@"scroll: %04x, player: %04x, sum: %04x"ascii, UU(scroll_x.a), UU(player_x.a), use_x)

    UU use_addr = $2000
    if use_x >= $100
        use_addr = $2400

    UU xy_addr = use_addr + (UU(player_y.a >> 3) << 5) + (use_x >> 3)
    if use_x >= $100
        xy_addr -= $20 // why?
    ppu_reset_addr(xy_addr)
    {PPUDATA}()
    UU tile_below = {PPUDATA}()
    if tile_below == ENEMY_ICON || tile_below == ENEMY_ICON_SCRATCH || tile_below == ENEMY_LEGS
        dead = true
    ppu_reset_addr(xy_addr + $20)
    {PPUDATA}()
    tile_below = {PPUDATA}()
    if tile_below == ENEMY_ICON || tile_below == ENEMY_ICON_SCRATCH || tile_below == ENEMY_LEGS
        dead = true
    // ppu_reset_addr(xy_addr)
    // {PPUDATA}(DEBUG_INDICATOR)
    // ppu_reset_addr(xy_addr + $20)
    // {PPUDATA}(DEBUG_INDICATOR)

    if frame & 3 == 0
        load_column()

    ppu_reset_scroll(scroll_x.a, 0) // 0, 0)
    {PPUCTRL}(PPUCTRL_NMI_ON | PPUCTRL_SPR_8X16 | active_nt)
    {PPUMASK}(PPUMASK_ON | PPUMASK_NO_CLIP)

fn emit_tile(U k)
: +inline
    if (use_chart{chart_offset} >> k) & 1
        {PPUDATA}(ENEMY_ICON)
        {PPUDATA}(ENEMY_LEGS)
    else
        {PPUDATA}(EMPTY_TOP_BORDER)
        {PPUDATA}(EMPTY_LANE)

fn load_column()
    if chart_offset == len(chart)
        won = true
        return

    {PPUCTRL}(PPUCTRL_VRAM_32_DOWN)

    {PPUSTATUS}()
    {PPUADDR}(tile_ppuaddr_table()[next_column].b)
    {PPUADDR}(tile_ppuaddr_table()[next_column].a)
    {PPUDATA}(EMPTY_TOP_BORDER)
    if (use_chart{chart_offset} >> 7) & 1
        {PPUDATA}(ENEMY_ICON_SCRATCH)
        {PPUDATA}(ENEMY_LEGS)
    else
        {PPUDATA}(EMPTY_LANE)
        {PPUDATA}(EMPTY_LANE)
    {PPUDATA}($00)
    emit_tile(6)
    emit_tile(5)
    emit_tile(4)
    emit_tile(3)
    emit_tile(2)
    emit_tile(1)
    emit_tile(0)
    {PPUDATA}(EMPTY_TOP_BORDER)

    next_column += 1
    if next_column == WIDTH_IN_TILES
        next_column = 0
    chart_offset += 1

mode game()
: nmi game_nmi
    {PPUCTRL}(0)
    {PPUMASK}(0)

    state(0)

    // this does not work with a 'ct' array??
    // I think this is the same thing that was going on with the delays in
    // attract mode
    // for U k = 0; k < len(tran_palette); k += 1
    //     palette[PALETTE_SPR + k] = tran_palette[k]
    // compiles to:
    // 8A2C  A9 2C          LDA #$2C
    // 8A2E  8D 0C 03       STA $030C
    // 8A31  8D 0D 03       STA $030D
    // 8A34  A2 30          LDX #$30
    // 8A36  8E 0E 03       STX $030E
    // 8A39  20 C0 8C       JSR ppu_upload_palette@0_0

    palette = game_palette
    ppu_upload_palette()
    
    ppu_reset_addr($2000)
    ppu_upload_rlz(@game_screen)
    ppu_reset_addr($2400)
    ppu_upload_rlz(@game_screen)

    for U k = 0; k < 10; k += 1
        load_column()

    hide_oam(0)
    
    {PPUCTRL}(PPUCTRL_NMI_ON)
    
    while !dead
        if won
            goto mode title(true) : preserves
        update_pads()

        U player_moving = pads[0].held & BUTTON_DPAD
        U player_flags = 0 // for horizontal flip
        UF new_x = player_x
        UF new_y = player_y

        if pads[0].held & BUTTON_RIGHT
            new_x += 1.5
        if pads[0].held & BUTTON_UP
            new_y -= 1.5
        if pads[0].held & BUTTON_LEFT
            new_x -= 1.5
            player_flags |= ATTR_H_FLIP
        if pads[0].held & BUTTON_DOWN
            new_y += 1.5
        
        if new_x >= MIN_X && new_x < MAX_X
            player_x = new_x
        if new_y >= MIN_Y && new_y < MAX_Y
            player_y = new_y

        U tile_left = TILE_LEFT_STANDING
        U tile_right = TILE_RIGHT_STANDING
        if anim_ctr >= 6 // && player_moving
            state(3)
            tile_left = TILE_LEFT_RUNNING
            tile_right = TILE_RIGHT_RUNNING
        else
            state(0)

        // need to swap the tile IDs not just the tile contents
        if player_flags
            U temp = tile_left
            tile_left = tile_right
            tile_right = temp

        set_oam(0, player_x.a - 4, player_y.a - 4, tile_left, player_flags)
        set_oam(4, player_x.a + 4, player_y.a - 4, tile_right, player_flags)

        scroll_x += 2
        if(scroll_x == 0)
            active_nt ^= PPUCTRL_NT_2400

        anim_ctr += 1
        if anim_ctr >= 12
            anim_ctr = 0

        //{PPUMASK}(PPUMASK_ON | PPUMASK_NO_CLIP | PPUMASK_EMPHASIZE_R | PPUMASK_EMPHASIZE_G | PPUMASK_EMPHASIZE_B)
        frame += 1
        nmi
    
    goto mode title(false) : preserves